signalrprovider
===============

F# Type Provider for SignalR with FunScript

Type provider giving a typed view of a .NET SignalR server Hub (could be C# or F#) to client-side code compiled
from F# to JavaScript with FunScript.

Next step, a type provider giving the reverse (typed view for F# server -> FunScript client calls).

How it works
============

Server project defines a SignalR Hub class: 

```fsharp
open Microsoft.AspNet.SignalR

[<HubName("myhub")>]
type MyHub() = 
    inherit Hub()
    
member this.frob(x: int) = 42 + x
```
    
The client uses FunScript, the FunScript bindings for SignalR, and has a reference to the server.
The client references the SignalRProvider, which searches for hubs (by attribute) in the referenced DLLs,
and exposes these

```fsharp
let signalR = Globals.Dollar.signalR  // FunsScript binding for SignalR TypeScript definition
let serverHub = new Hubs.myhub(signalR.hub) // Hubs.myhub type generated by SignalRProvider from above definition
```    
    
Then when a method on the hub is called, it will be typechecked at *compile time* of the FunScript code.

```fsharp
serverHub.frob(10); // OK
serverHub.frob("string") // Fail to compile
serverHub.foo(10) // Fail to compile
```
    
Issues
======
* Reflection to examine referenced assemblies is a horrible appdomain-creating mess. I hope I got it right, it was painful enough.
* Only 1-way at present. Will be a bit of a circular reference situation when the other half comes, as well.
* Return types of deferred object not right yet.
* Assumes all hubs defined are available at the configured hub URL
